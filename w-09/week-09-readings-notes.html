<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WDD 330 | Week 09 Readings notes</title>
  <style>
    body {
      font: 14px/20px BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
      color: #313130;
      background: #fff;
      margin: 0 auto;
      width: 90%;
    }

    .alert {
      padding: 15px;
      border: 1px solid #d6e9c6;
      border-radius: 4px;
      color: #3c763d;
      background-color: #dff0d8;
    }

    .one {
      color: #2d3b45;
      display: block;
      padding: 2px;
      margin: 0 0 2px;
      white-space: pre;
      white-space: pre-wrap;
    }

    .two {
      font-size: .75rem;
      border-radius: 6px;
      background-color: #f5f5f5;
      border: 1px solid #c7cdd1;
      word-break: break-all;
      word-wrap: break-word;
      white-space: pre;
      white-space: pre-wrap;
    }

    h1,
    h2,
    p {
      margin: 2px;
      padding: 2px;
      font-size: large;
    }

    code {
      font-family: "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
      background: #f7f4f3;
      border-radius: 2px;
      color: #716f6e;
    }
  </style>
</head>

<body>
  <br>
  <div class="alert"> <strong>
      Hector Olivares Tapia |
      Brigham Young University-Idaho |
      WDD 330 Web Frontend Development II |
      Week 09: Readings notes|
      Instructor Edward Nelson |
      Nov 11, 2023</strong>
  </div>
  <br>
<pre class="one">

      <a href="https://javascript.info/closure" target="_blank" rel="noreferrer">6.3 Variable Scope, Closure</a>

      <a href="https://javascript.info/currying-partials" target="_blank" rel="noreferrer">14.3 Currying</a>

      <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Drawing_graphics" target="_blank" rel="noreferrer">Web APIs: Drawing Graphics</a>

    
</pre>
  <br>
<pre class="one">
<h2>Variable Scope, Closure</h2>

  <p>The article explains that JavaScript is a function-oriented language that allows functions to be created at any moment, passed as an argument to another function, and then called from a totally different place of code later. The article also explains that a function can access variables outside of it (“outer” variables), but what happens if outer variables change since a function is created? Will the function get newer values or the old ones? And what if a function is passed along as an argument and called from another place of code, will it get access to outer variables at the new place? The article goes on to explain these scenarios and more complex ones.</p>
  <p>In JavaScript, there are 3 ways to declare a variable: <code>let</code>, <code>const</code> (the modern ones), and <code>var</code> (the remnant of the past). The article uses <code>let</code> variables in examples. Variables, declared with <code>const</code>, behave the same, so this article is about <code>const</code> too. The old <code>var</code> has some notable differences.</p>
  <p>A closure in JavaScript is like keeping a reference (NOT a copy) to the scope at the point of function declaration, which in turn keeps a reference to its outer scope, and so on, all the way to the global object at the top of the scope chain <a href="https://stackoverflow.com/questions/111102/how-do-javascript-closures-work" class="ac-anchor" target="_blank" is="cib-link" appearance="system-link" h="ID=SERP,5026.1">2</a>. The article explains that a closure is a function having access to the parent scope, even after the parent function has closed. The article also explains that closures are created every time a function is created, at function creation time. Lexical scoping is used to determine the scope of variables <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" class="ac-anchor" target="_blank" is="cib-link" appearance="system-link" h="ID=SERP,5026.1">4</a>.</p>

  <p>The main difference between <code>let</code> and <code>var</code> in JavaScript is their <strong>scope</strong>. Variables declared with <code>var</code> are <strong>function-scoped</strong>, meaning they are accessible throughout the entire function in which they are declared, even if they are declared inside a block statement. On the other hand, variables declared with <code>let</code> are <strong>block-scoped</strong>, meaning they are only accessible within the block in which they are declared <a href="https://stackoverflow.com/questions/762011/what-is-the-difference-between-let-and-var" class="ac-anchor sup-target" target="_blank">5</a> <a href="https://www.codingem.com/let-vs-var-javascript/" class="ac-anchor sup-target" target="_blank">6</a> <a href="https://javascriptsource.com/the-difference-between-var-and-let-in-javascript/" class="ac-anchor sup-target" target="_blank">7</a>.</p>
  <p>Another difference between <code>let</code> and <code>var</code> is that <code>var</code> variables are <strong>hoisted</strong> and initialized to <code>undefined</code> before the code is executed, while <code>let</code> variables are not initialized until their definition is evaluated <a href="https://stackoverflow.com/questions/762011/what-is-the-difference-between-let-and-var" target="_blank">8</a> <a href="https://www.codingem.com/let-vs-var-javascript/" target="_blank" >9</a>.</p>
  <p>In summary, <code>var</code> has function scope and <code>let</code> has block scope. The difference between these two is that <code>var</code> variables are accessible within the entire function and <code>let</code> variables are accessible only within the block they are declared <a href="https://javascriptsource.com/the-difference-between-var-and-let-in-javascript/" target="_blank">10</a>.</p>
 
</pre>
<br>
<pre class="one">
  <h2>Currying</h2>
  <p>The article explains that currying is a transformation of functions that translates a function from callable as f (a, b, c) into callable as f (a) (b) (c). Currying doesn’t call a function. It just transforms it. The article also explains that JavaScript implementations usually both keep the function callable normally and return the partial if the arguments count is not enough. Currying allows us to easily get partials. The article provides an example of a helper function curry (f) that performs currying for a two-argument f. In other words, curry (f) for two-argument f (a, b) translates it into a function that runs as f (a) (b). The article also explains that more advanced implementations of currying, such as _.curry from lodash library, return a wrapper that allows a function to be called both normally and partially <a href="https://javascript.info/currying-partials"  target="_blank">1</a>.</p>
</pre>
 <br>
 <pre class="one">
  <h2>Web APIs: Drawing Graphics</h2>
  <p>The article explains that web APIs for drawing and manipulating graphics are now widely supported in browsers. The most popular ones are Canvas and WebGL, which allow you to programmatically update the pixel data contained in an HTML &lt;canvas&gt; element to create 2D and 3D scenes. The article also explains that the Canvas API is a powerful 2D drawing API that allows you to draw graphics on a web page using JavaScript. The article provides a detailed guide on how to use the Canvas API to draw graphics, including how to draw lines, shapes, text, and images. The article also explains how to use the WebGL API to create 3D graphics on a web page. The article provides a detailed guide on how to use the WebGL API to create 3D scenes, including how to create a scene, add objects to the scene, and apply textures and lighting to the objects.</p>
</pre>
</body>
</html>
